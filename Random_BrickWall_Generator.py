import open3d as o3d
import numpy as np
import matplotlib.pyplot as plt
import os
import sys
from scipy.interpolate import interp1d 
import pyvista as pv
import cv2

'''
Project: RCCN-Assembly
2023/07/14 in RAC-Coon,NCKU. GitHub.
Coded by Shih-Yu,Lai.
Advised by Chia-Ching,Yen.

This code ramdomly generates the brick wall with the point cloud data in curves, assume the boxes are the bricks.
The boxes are generated by the cubic interpolation model, and the curve is generated by the random points in the xz plane.
The curve is duplicated with the points and translate with the y and z direction as the n+1 layer which overlay the n layer with for loop.
Draw the boxes with the vertices and edges of mesh, then save all boxes into one .obj file in the assign folder.
'''

# Generate random points in the xz plane
num_points = 10 # Number of points to generate
points = np.random.rand(num_points, 3)
points[:, 1] = 0.0  # Set y-coordinate to 0 to keep points in the xz plane

# Extract x and z coordinates from the points
x = points[:, 0]
z = points[:, 2]

# Create cubic interpolation model
cubic_interpolation_model = interp1d(x, z, kind="cubic")

# Create a curve by evaluating the cubic interpolation model
curve_points = np.linspace(x.min(), x.max(), num=300) # 100 points between x.min and x.max (inclusive) 
curve = np.column_stack((curve_points, cubic_interpolation_model(curve_points), np.zeros_like(curve_points)))

# Visualize the curve using Open3D
curve_cloud = o3d.geometry.PointCloud()
curve_cloud.points = o3d.utility.Vector3dVector(curve) #n layer

# Draw the curve
#o3d.visualization.draw_geometries([curve_cloud])

# Reduplicate another curve with the points and translate 0.0090 with the y direction and 0.0095 with the z direction as the n+1 layer which overlay the n layer with for loop
layers = 6
curve_n = curve.copy()
curves = []
for i in range(layers):
    curve_n[:, 1] = curve_n[:, 1] + 0.0090
    curve_n[:, 2] = curve_n[:, 2] + 0.0095
    curves.append(curve_n.copy())

# Crate the boxes from points in the curves with for loop
boxes = []
for i in range(layers):
    curve_cloud_n = o3d.geometry.PointCloud()
    curve_cloud_n.points = o3d.utility.Vector3dVector(curves[i])
    for i in range(curve_cloud_n.points.__len__()):
        box = o3d.geometry.TriangleMesh.create_box(width=0.0090, height=0.0190, depth=0.0090)
        box.translate(curve_cloud_n.points[i])
        boxes.append(box)
   
# Draw the boxes with the vertices and edges of mesh in color
o3d.visualization.draw_geometries(boxes, mesh_show_wireframe=True, mesh_show_back_face=True)


#Save all boxes into one .obj file in the download folder
# Create a mesh object to store all the boxes
all_boxes_mesh = o3d.geometry.TriangleMesh()

# Combine all the boxes into a single mesh
for box in boxes:
    all_boxes_mesh += box

# Specify the path to save the OBJ file
path = r"C:\Users\Acer\Downloads\BrickWallFile"
save_path = os.path.join(path, "BrickWall.obj")

# Save the combined mesh as an OBJ file
o3d.io.write_triangle_mesh(save_path, all_boxes_mesh)

# Automatically produce a video to record the combined mesh with 360 degrees camera view and zoom in
# Create a window to visualize all_boxes_mesh
view = o3d.visualization.VisualizerWithKeyCallback()
view.create_window()
# Add the all_boxes_mesh to the visualization
view.add_geometry(all_boxes_mesh)

# Set the camera view
view_control = view.get_view_control()
view_control.set_front([0, 0, -1])
view_control.set_up([0, 1, 0])
view_control.set_zoom(0.5)
view_control.set_lookat([0, 0, 0])

# Set video recording parameters
width = 1280
height = 720
fps = 30
duration = 10  # Duration of the video in seconds

# Initialize the video writer
#Save the video file in the path with the name BrickWall.mp4
fourcc = cv2.VideoWriter_fourcc(*"mp4v")
save_path_video = os.path.join(path, "BrickWall.mp4")
video_writer = cv2.VideoWriter(save_path_video, fourcc, fps, (width, height))

# Release the video writer and close the visualization window
video_writer.release()
view.destroy_window()
